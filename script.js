let board = document.querySelector(".grid");
const startButton = document.getElementById("start-button");
const container = document.querySelector(".container");
const coverScreen = document.querySelector(".cover-screen");
const result = document.getElementById("result");
const overText = document.getElementById("over-text");

let matrix,
    // Оголошуємо змінну `matrix`, яка буде представляти ігрове поле (матрицю)
    score,
    // Оголошуємо змінну `score`, яка буде зберігати поточний рахунок гравця
    rows = 4,
    // Встановлюємо кількість рядків в ігровому полі (4x4 сітка)
    columns = 4,
    // Встановлюємо кількість стовпців в ігровому полі (4x4 сітка)
    swipeDirection;
    // Оголошуємо змінну `swipeDirection`, яка буде вказувати напрямок свайпу

// Функція `createGrid` створює ігрову сітку, додаючи div-елементи (клітинки) на ігрове поле (grid)
// Оголошуємо функцію createGrid, яка буде створювати сітку гри
function createGrid() {
    // Цикл для ітерації через рядки сітки
    for (let i = 0; i < rows; i++) {
        // Вкладений цикл для ітерації через стовпці сітки
        for (let j = 0; j < columns; j++) {
            
            const boxDiv = document.createElement("div");
            // Створюємо новий елемент <div>, який представлятиме одну клітинку сітки гри

            boxDiv.classList.add("box");
            // Додаємо клас "box" до елементу <div>, для стилізації та відображення клітинок

            // Встановлюємо атрибут "data-position" для елементу <div> зі значенням координат рядка і стовпця
            // Цей атрибут використовується для визначення позиції клітинки в сітці гри
            boxDiv.setAttribute("data-position", `${i}_${j}`);

            // Додаємо створений елемент <div> (клітинку) в сітку гри (елемент з класом "grid")
            board.appendChild(boxDiv);
        }
    }
}

// Оголошуємо функцію `adjacentCheck`, яка перевіряє, чи є суміжний однаковий елемент у масиві `arr`
function adjacentCheck(arr){
    // Проходимось по масиву `arr` за допомогою циклу
    for (let i = 0; i < arr.length - 1; i++) {
        // Перевіряємо, чи поточний елемент `arr[i]` дорівнює наступному елементу `arr[i + 1]`
        if (arr[i] === arr[i + 1]) {
            // Якщо умова виконується, то повертаємо `true`, означаючи, що є поручні однакові елементи
            return true;
        }
    }
    // Якщо ж усі пари сусідніх елементів були різні, повертаємо `false`
    return false;
}

// Оголошуємо функцію `possibleMovesCheck`, яка перевіряє, чи є можливі рухи в грі
function possibleMovesCheck() {
    // Проходимось по кожному рядку в матриці `matrix`
    for (let i in matrix) {
        // Перевіряємо, чи є суміжні однакові елементи в поточному рядку матриці `matrix`
        if (adjacentCheck(matrix[i])) {
            // Якщо така пара поручних однакових елементів знайдена в рядку, повертаємо `true`,
            // означаючи, що є можливі рухи у грі
            return true;
        }

        // Створюємо масив `colarr`, який буде містити елементи поточного стовпця
        let colarr = [];
        // Проходимось по кожному рядку матриці для поточного стовпця
        for (let j = 0; j < columns; j++) {
            // Додаємо елемент з поточного стовпця до масиву `colarr`
            colarr.push(matrix[i][j]);
        }
        // Перевіряємо, чи є суміжні однакові елементи в масиві `colarr`
        if (adjacentCheck(colarr)) {
            // Якщо така пара поручних однакових елементів знайдена в стовпці, повертаємо `true`,
            // означаючи, що є можливі рухи у грі
            return true;
        }
    }
    // Якщо не знайдено пар поручних однакових елементів в рядках або стовпцях,
    // повертаємо `false`, означаючи, що немає можливих рухів у грі
    return false;
}

function randomPosition(arr) {
    // Генеруємо випадкове число від 0 до (arr.length - 1)
    // Це випадковий індекс у межах довжини масиву
    return Math.floor(Math.random() * arr.length);
    /*Math.random(): Це вбудована функція в JavaScript, яка генерує псевдовипадкове число в діапазоні від 0 (включно) до 1 (виключно). 
    Це число представляє собою випадковий відсоток, що допомагає створювати випадкові значення.
    * arr.length: У цьому контексті ми беремо псевдовипадкове число, згенероване Math.random(), і множимо його на довжину масиву arr. 
    Результат цього множення буде випадковим числом в діапазоні від 0 (включно) до arr.length (виключно).
    Math.floor(...): Функція Math.floor() відкидає дробову частину числа і залишає тільки цілу частину. 
    Це призводить до округлення вниз, що в даному випадку важливо, оскільки нам потрібен цілий індекс для доступу до елементів масиву.
    return ...;: Остаточне обчислене значення після всіх кроків 
    (генерування випадкового відсотка, множення на довжину масиву та округлення вниз) повертається з функції як її результат.

    Отже, рядок return Math.floor(Math.random() * arr.length); визначає випадковий індекс в масиві arr і повертає його як результат функції. 
    Цей індекс може бути використаний для доступу до випадкового елемента в масиві.
*/
}

// Оголошуємо функцію hasEmptyBox без параметрів
function hasEmptyBox(){
    // Проходимось по рядках матриці
    for (let r in matrix) {
        // Проходимось по стовпцях в поточному рядку
        for (let c in matrix[r]) {
            // Перевіряємо, чи значення в поточній клітинці матриці дорівнює 0
            if (matrix[r][c] === 0) {
                // Якщо знайдена порожня клітина, повертаємо true
                return true;
            }
        }
    }
    // Якщо всі клітини були перевірені і порожньої не знайдено, повертаємо false
    return false;
}

// Функція перевіряє, чи гра завершилася (чи більше немає можливих ходів)
function gameOverCheck() {
    // Викликаємо функцію `possibleMovesCheck`, яка перевіряє, чи є можливі ходи
    if (!possibleMovesCheck()) {
        // Якщо не залишилося можливих ходів, то виконуємо наступні дії:

        // Приховуємо елемент з класом "cover-screen", який прикриває ігрове поле
        coverScreen.classList.remove("hide");

        // Додаємо клас "hide" до елемента з класом "container", що містить ігрове поле
        container.classList.add("hide");

        // Видаляємо клас "hide" з елемента з класом "over-text", який відображає повідомлення про завершення гри
        overText.classList.remove("hide");

        // Змінюємо текст елемента з id "result", щоб показати кінцевий рахунок гравця
        result.innerText = `Final score: ${score}`;

        // Змінюємо текст кнопки старту, щоб вона показувала "Restart Game"
        startButton.innerText = "Restart Game";
    }
}